function _check_private_redeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _class_apply_descriptor_get(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _class_apply_descriptor_set(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _class_extract_field_descriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _class_private_field_get(receiver, privateMap) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "get");
    return _class_apply_descriptor_get(receiver, descriptor);
}
function _class_private_field_init(obj, privateMap, value) {
    _check_private_redeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _class_private_field_set(receiver, privateMap, value) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "set");
    _class_apply_descriptor_set(receiver, descriptor, value);
    return value;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
import { inspect } from 'util';
import { SyncOptions } from '@ceramicnetwork/common';
import { getResolver as get3IDResolver } from '@ceramicnetwork/3id-did-resolver';
import { CeramicClient } from '@ceramicnetwork/http-client';
import { Args, Command as CoreCommand, Flags } from '@oclif/core';
import { DID } from 'dids';
import { Ed25519Provider } from 'key-did-provider-ed25519';
import { getResolver as getKeyResolver } from 'key-did-resolver';
import ora from 'ora';
import { fromString } from 'uint8arrays';
// TODO: SYNC_OPTIONS_MAP is also used in js-ceramic/packages/cli. Move this const to '@ceramicnetwork/common'
export const SYNC_OPTIONS_MAP = {
    'prefer-cache': SyncOptions.PREFER_CACHE,
    'sync-always': SyncOptions.SYNC_ALWAYS,
    'never-sync': SyncOptions.NEVER_SYNC
};
export const STREAM_ID_ARG = Args.string({
    required: true,
    description: 'ID of the stream'
});
/* Not using Flags.string.parse, because it's not supported anymore to either:
   a. have a Flags.integer flag with a string input and parse(...) returning an integer
   b. have a Flags.string flag with and parse(...) returning an integer
   , and the httpClient expects an integer, while we want to have this option as a string flag in the cli
**/ export const parseSyncFlag = (value)=>{
    if (value === undefined || SYNC_OPTIONS_MAP[value] === undefined) {
        return SyncOptions.PREFER_CACHE;
    }
    return SYNC_OPTIONS_MAP[value];
};
export const SYNC_OPTION_FLAG = Flags.string({
    required: false,
    options: Object.keys(SYNC_OPTIONS_MAP),
    description: `Controls if the current stream state should be synced over the network or not. 'prefer-cache' will return the state from the node's local cache if present, and will sync from the network if the stream isn't in the cache. 'always-sync' always syncs from the network, even if there is cached state for the stream. 'never-sync' never syncs from the network.`
});
const readPipe = ()=>{
    return new Promise((resolve)=>{
        let data = '';
        const stdin = process.openStdin();
        const finish = ()=>{
            resolve(data.length > 0 ? data.trim() : undefined);
            stdin.pause();
        };
        stdin.setEncoding('utf-8');
        stdin.on('data', (chunk)=>{
            data += chunk;
        });
        stdin.on('end', ()=>{
            finish();
        });
        if (stdin.isTTY) {
            finish();
        } else {
            setTimeout(()=>{
                finish();
            }, 8000);
        }
    });
};
export class BaseCommand extends CoreCommand {
    async init() {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore constructor type
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const { args, flags } = await this.parse(this.constructor);
        this.args = args;
        this.flags = flags;
        this.spinner = ora();
        this.stdin = await readPipe();
    }
    logJSON(data) {
        this.log(inspect(data, {
            colors: true,
            depth: null
        }));
    }
    constructor(...args){
        super(...args);
        _define_property(this, "args", void 0);
        _define_property(this, "flags", void 0);
        _define_property(this, "stdin", void 0);
        _define_property(this, "spinner", void 0);
    }
}
var _authenticatedDID = /*#__PURE__*/ new WeakMap(), _ceramic = /*#__PURE__*/ new WeakMap(), _resolverRegistry = /*#__PURE__*/ new WeakMap();
export class Command extends BaseCommand {
    async init() {
        await super.init();
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore constructor type
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const { args, flags } = await this.parse(this.constructor);
        this.args = args;
        this.flags = flags;
        // Authenticate the Ceramic instance whenever a key is provided
        if (this.flags['did-private-key'] != null) {
            const did = await this.getAuthenticatedDID(this.flags['did-private-key']);
            this.spinner.info(`Using DID ${did.id}`);
            _class_private_field_set(this, _authenticatedDID, did);
            this.ceramic.did = did;
        }
    }
    async finally() {
        if (_class_private_field_get(this, _ceramic) != null) {
            await _class_private_field_get(this, _ceramic).close();
        }
    }
    get authenticatedDID() {
        if (_class_private_field_get(this, _authenticatedDID) == null) {
            throw new Error('DID is not authenticated, make sure to provide a private key using the "did-private-key" flag');
        }
        return _class_private_field_get(this, _authenticatedDID);
    }
    get ceramic() {
        if (_class_private_field_get(this, _ceramic) == null) {
            _class_private_field_set(this, _ceramic, new CeramicClient(this.flags['ceramic-url']));
        }
        return _class_private_field_get(this, _ceramic);
    }
    get resolverRegistry() {
        if (_class_private_field_get(this, _resolverRegistry) == null) {
            _class_private_field_set(this, _resolverRegistry, {
                ...getKeyResolver(),
                ...get3IDResolver(this.ceramic)
            });
        }
        return _class_private_field_get(this, _resolverRegistry);
    }
    getProvider(seed) {
        return new Ed25519Provider(fromString(seed, 'base16'));
    }
    getDID() {
        return new DID({
            resolver: this.resolverRegistry
        });
    }
    async getAuthenticatedDID(seed) {
        try {
            const did = this.getDID();
            did.setProvider(this.getProvider(seed));
            await did.authenticate();
            return did;
        } catch (err) {
            this.warn(`Invalid DID private key.  Did you generate the private key using 'composedb did:generate-private-key'?`);
            throw err;
        }
    }
    constructor(...args){
        super(...args);
        _define_property(this, "args", void 0);
        _define_property(this, "flags", void 0);
        _class_private_field_init(this, _authenticatedDID, {
            writable: true,
            value: null
        });
        _class_private_field_init(this, _ceramic, {
            writable: true,
            value: null
        });
        _class_private_field_init(this, _resolverRegistry, {
            writable: true,
            value: null
        });
    }
}
_define_property(Command, "flags", {
    'ceramic-url': Flags.string({
        char: 'c',
        description: 'Ceramic API URL',
        env: 'CERAMIC_URL'
    }),
    'did-private-key': Flags.string({
        char: 'k',
        description: 'DID private key',
        env: 'DID_PRIVATE_KEY'
    })
});
