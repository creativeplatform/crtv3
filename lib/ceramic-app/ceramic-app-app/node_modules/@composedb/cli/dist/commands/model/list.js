function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
import { BaseCommand } from '../../command.js';
import { Flags, ux } from '@oclif/core';
import { Model } from '@ceramicnetwork/stream-model';
import Table from 'cli-table3';
import terminalSize from 'terminal-size';
import { CeramicClient } from '@ceramicnetwork/http-client';
class ModelList extends BaseCommand {
    getPageSize() {
        const rows = terminalSize()['rows'];
        // When we display a table, each row is takes two terminal rows. We subtract additional 3 lines per page, to leave
        // space for the table header and next page prompt
        return Math.round(Math.max(20, this.flags.table ? rows / 2 - 3 : rows));
    }
    getIndexerForNetwork(network) {
        switch(network){
            case 'mainnet':
                return 'https://ceramic-private.3boxlabs.com';
            case 'testnet-clay':
                return 'https://ceramic-private-clay.3boxlabs.com/';
            case 'dev-unstable':
                return 'https://ceramic-private-qa.3boxlabs.com/';
            default:
                throw new Error(`Unrecognized Ceramic network ${network}. Valid values are 'mainnet', 'testnet-clay', and 'dev-unstable'`);
        }
    }
    getIndexerUrl() {
        const network = this.flags['network'];
        let indexerUrl = this.getIndexerForNetwork(network);
        const indexerUrlFlag = this.flags['indexer-url'];
        if (indexerUrlFlag) {
            indexerUrl = indexerUrlFlag;
        }
        return indexerUrl;
    }
    async run() {
        try {
            console.clear();
            this.spinner.start('Loading models...');
            const ceramicIndexer = new CeramicClient(this.getIndexerUrl());
            const page = await ceramicIndexer.index.query({
                first: this.getPageSize(),
                model: Model.MODEL
            });
            this.lastLoadedPageInfo = page.pageInfo;
            this.fetchedFields = this.fetchedFields.concat(this.getFieldsFromEdges(ceramicIndexer, page.edges));
            this.displayPartialDefinitions(this.fetchedFields);
            while(this.lastLoadedPageInfo?.hasNextPage){
                this.spinner.stop();
                await this.anykeyWithFriendlyExit('Press ctrl+c or q to quit. Press any other key to continue loading models.', 'Stopped loading models due to user input');
                this.spinner.start('Loading models...');
                const nextPage = await ceramicIndexer.index.query({
                    first: this.getPageSize(),
                    model: Model.MODEL,
                    after: this.lastLoadedPageInfo?.endCursor
                });
                this.lastLoadedPageInfo = nextPage.pageInfo;
                this.fetchedFields = this.fetchedFields.concat(this.getFieldsFromEdges(ceramicIndexer, nextPage.edges));
                this.displayPartialDefinitions(this.fetchedFields);
            }
            this.spinner.succeed('Loading models... Done');
        } catch (e) {
            this.spinner.fail(e.message);
            return;
        }
    }
    async anykeyWithFriendlyExit(message, exitMessage) {
        const tty = process.stdin.setRawMode !== undefined;
        const char = await ux.prompt(message, {
            type: 'single',
            required: false
        });
        if (tty) process.stderr.write('\n');
        if (char === 'q' || char === '\u0003') {
            this.spinner.succeed(exitMessage);
            process.exit();
        }
    }
    getFieldsFromEdges(ceramicIndexer, edges) {
        return edges.map((edge)=>{
            if (edge?.node == null) {
                return null;
            }
            const stream = ceramicIndexer.buildStreamFromState(edge.node);
            return {
                id: stream.id.toString(),
                name: stream.content.name,
                description: stream.content.description
            };
        }).filter(Boolean);
    }
    displayPartialDefinitions(definitions) {
        console.clear();
        if (this.flags.table === true) {
            const table = new Table({
                head: [
                    'Name',
                    'Description'
                ],
                colWidths: [
                    32,
                    52
                ]
            });
            definitions.forEach((definition)=>{
                table.push([
                    {
                        content: definition.name
                    },
                    {
                        content: definition.description,
                        truncate: '...'
                    }
                ]);
                table.push([
                    {
                        colSpan: 2,
                        content: `ID: ${definition.id.toString()}`
                    }
                ]);
            });
            // Not using the spinner here, so that the table is laid out properly
            this.log(`${table.toString()}\n`);
        } else {
            let output = '';
            definitions.forEach((definition)=>{
                output += `${JSON.stringify(definition)}\n`;
            });
            this.log(output);
        }
    }
    constructor(...args){
        super(...args);
        _define_property(this, "fetchedFields", []);
        _define_property(this, "lastLoadedPageInfo", null);
    }
}
_define_property(ModelList, "description", 'load a list of models with pagination');
_define_property(ModelList, "flags", {
    ...BaseCommand.flags,
    'indexer-url': Flags.string({
        char: 'i',
        description: 'URL of a Ceramic API that indexes all models',
        exclusive: [
            'network'
        ]
    }),
    table: Flags.boolean({
        description: 'display the results as a table'
    }),
    network: Flags.string({
        default: 'mainnet',
        char: 'n',
        description: 'Which Ceramic network you want to list models for'
    })
});
export { ModelList as default };
