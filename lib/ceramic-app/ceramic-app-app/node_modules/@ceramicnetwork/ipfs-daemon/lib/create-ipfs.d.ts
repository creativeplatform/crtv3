import * as Ctl from 'ipfsd-ctl';
import type { IpfsApi } from '@ceramicnetwork/common';
import { RustIpfsOptions } from './rust-ipfs.js';
import { IPFSOptions as GoIpfsOptions } from 'ipfsd-ctl';
import { DiagnosticsLogger } from '@ceramicnetwork/common';
export declare function createGoController(ipfsOptions: Ctl.IPFSOptions, disposable?: boolean): Promise<Ctl.Controller>;
declare function createIpfsOptions(override?: Partial<Ctl.IPFSOptions>, repoPath?: string): Promise<Ctl.IPFSOptions>;
export declare type GoIpfsFlavor = {
    name: 'go';
    options: GoIpfsOptions;
};
export declare type RustIpfsFlavor = {
    name: 'rust';
    options: RustIpfsOptions;
};
declare type IpfsFlavor = GoIpfsFlavor | RustIpfsFlavor;
declare type createIpfsOptions = {
    rust?: RustIpfsOptions;
    go?: GoIpfsOptions;
};
export declare function createIPFS(options?: createIpfsOptions, disposable?: boolean): Promise<IpfsApi>;
export interface RunningIpfs {
    api(): IpfsApi;
    shutdown(logger?: DiagnosticsLogger): Promise<void>;
}
export declare function createIPFSFlavor(flavor: IpfsFlavor, disposable?: boolean): Promise<RunningIpfs>;
export declare function swarmConnect(a: IpfsApi, b: IpfsApi): Promise<void>;
export declare function withFleet(n: number, task: (instances: IpfsApi[]) => Promise<void>, overrideConfig?: Record<string, unknown>): Promise<void>;
export {};
//# sourceMappingURL=create-ipfs.d.ts.map