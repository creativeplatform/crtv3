import getPort from 'get-port';
import tmp from 'tmp-promise';
import { Networks } from '@ceramicnetwork/common';
import { create as createIpfsClient } from 'ipfs-http-client';
import { spawn } from 'child_process';
class BinaryRunningIpfs {
    constructor(proc, api, dir) {
        this.proc = proc;
        this.dir = dir;
        const shutdown = this.shutdown.bind(this);
        this._api = new Proxy(api, {
            get(target, p) {
                if (p === 'stop') {
                    return shutdown;
                }
                return target[p];
            },
        });
    }
    api() {
        return this._api;
    }
    async shutdown(logger) {
        try {
            this.proc.kill();
            await this.dir.cleanup();
        }
        catch (e) {
            if (logger) {
                logger.err(`Failed to shutdown binary Rust IPFS: ${e}`);
            }
        }
    }
}
async function binary(binary_path, networkName, port, storeDir, networkId = 0) {
    let dir, apiPort, testExtras = [];
    const isTest = !storeDir && networkName === Networks.INMEMORY;
    if (!isTest) {
        storeDir = storeDir || '~/.ceramic-one';
        dir = {
            path: storeDir,
            cleanup: async () => {
            },
        };
        apiPort = port || 5101;
    }
    else {
        apiPort = port || (await getPort());
        dir = await tmp.dir({ unsafeCleanup: true });
        const metricsPort = await getPort();
        testExtras = [
            '--metrics-bind-address',
            `0.0.0.0:${metricsPort}`,
            '--swarm-addresses',
            '/ip4/0.0.0.0/udp/0/quic-v1',
        ];
    }
    const parameters = [
        'daemon',
        '--bind-address',
        `0.0.0.0:${apiPort}`,
        '--store-dir',
        dir.path,
        '--p2p-key-dir',
        dir.path,
        '--network',
        networkName === Networks.INMEMORY ? 'in-memory' : networkName,
        '--local-network-id',
        networkId.toString(),
    ].concat(testExtras);
    const proc = spawn(binary_path, parameters, {
        env: {
            RUST_LOG: process.env.RUST_LOG || 'info',
        },
        stdio: 'inherit',
    });
    const ipfs = createIpfsClient({
        host: '127.0.0.1',
        port: apiPort,
    });
    ipfs.config.get = async (key) => {
        if (key === 'Addresses.API') {
            return `http://127.0.0.1:${apiPort}`;
        }
        return '';
    };
    let ipfsOnline = false;
    while (!ipfsOnline) {
        try {
            await ipfs.id();
            ipfsOnline = true;
        }
        catch (e) {
            await new Promise((f) => setTimeout(f, 1000));
        }
    }
    return new BinaryRunningIpfs(proc, ipfs, dir);
}
class RemoteRunningIpfs {
    constructor(api) {
        this._api = api;
    }
    api() {
        return this._api;
    }
    isOnline() {
        return this._api.isOnline();
    }
    async shutdown() {
    }
}
async function remote(host, port) {
    const resolvedHost = host || 'localhost';
    const resolvedPort = port || 5101;
    const ipfs = createIpfsClient({
        host: resolvedHost,
        port: resolvedPort,
    });
    ipfs.config.get = async (key) => {
        if (key === 'Addresses.API') {
            return `https://${resolvedHost}:${resolvedPort}`;
        }
        return '';
    };
    const p = new Proxy(ipfs, {
        get(target, p) {
            if (p === 'stop') {
                return () => undefined;
            }
            return target[p];
        },
    });
    return new RemoteRunningIpfs(p);
}
export class RustIpfs {
    constructor(opts) {
        let options = opts;
        if (!options || Object.keys(options).length === 0) {
            options = RustIpfs.defaultOptions();
        }
        this.opts = options;
    }
    static defaultOptions(desiredNetwork) {
        const path = process.env.CERAMIC_ONE_PATH;
        if (!path) {
            throw new Error('Missing rust ceramic binary path. Set CERAMIC_ONE_PATH=/path/to/binary. For example: `CERAMIC_ONE_PATH=/usr/local/bin/ceramic-one`.');
        }
        let network;
        switch (desiredNetwork || process.env.CERAMIC_ONE_NETWORK) {
            case 'mainnet':
                network = Networks.MAINNET;
                break;
            case 'testnet-clay':
                network = Networks.TESTNET_CLAY;
                break;
            case 'dev-unstable':
                network = Networks.DEV_UNSTABLE;
                break;
            case 'local':
                network = Networks.LOCAL;
                break;
            default:
                network = Networks.INMEMORY;
        }
        const storeDir = process.env.CERAMIC_ONE_STORE_DIR;
        return {
            path,
            type: 'binary',
            network,
            port: null,
            storeDir,
        };
    }
    async start() {
        if (!this.api) {
            if (!this.opts.type) {
                throw new Error('Rust IPFS requires a type');
            }
            switch (this.opts.type) {
                case 'remote': {
                    this.api = await remote(this.opts.host, this.opts.port);
                    break;
                }
                case 'binary': {
                    this.api = await binary(this.opts.path, this.opts.network, this.opts.port, this.opts.storeDir, this.opts.networkId);
                    break;
                }
            }
        }
        return this.api;
    }
}
//# sourceMappingURL=rust-ipfs.js.map