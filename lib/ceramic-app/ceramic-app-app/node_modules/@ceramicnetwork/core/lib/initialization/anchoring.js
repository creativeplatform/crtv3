import { Networks } from '@ceramicnetwork/common';
import { DIDAnchorServiceAuth } from '../anchor/auth/did-anchor-service-auth.js';
import { InMemoryAnchorService } from '../anchor/memory/in-memory-anchor-service.js';
import { AuthenticatedEthereumAnchorService, EthereumAnchorService, } from '../anchor/ethereum/ethereum-anchor-service.js';
export const DEFAULT_ANCHOR_SERVICE_URLS = {
    [Networks.MAINNET]: 'https://cas.3boxlabs.com',
    [Networks.TESTNET_CLAY]: 'https://cas-clay.3boxlabs.com',
    [Networks.DEV_UNSTABLE]: 'https://cas-qa.3boxlabs.com',
    [Networks.LOCAL]: 'http://localhost:8081',
};
const SUPPORTED_CHAINS_BY_NETWORK = {
    [Networks.MAINNET]: ['eip155:1'],
    [Networks.TESTNET_CLAY]: ['eip155:3', 'eip155:4', 'eip155:100'],
    [Networks.DEV_UNSTABLE]: ['eip155:3', 'eip155:4', 'eip155:5', 'eip155:11155111'],
    [Networks.LOCAL]: ['eip155:1337'],
    [Networks.INMEMORY]: ['inmemory:12345'],
};
export class UnusableAnchorChainsError extends Error {
    constructor(network, casURL, availableChains, supportedChains) {
        super(`No usable chainId for anchoring was found.  The ceramic network '${network}' supports the chains: ['${supportedChains.join("', '")}'], but the configured anchor service '${casURL}' only supports the chains: ['${availableChains.join("', '")}']`);
    }
}
const TRAILING_SLASH = new RegExp(/\/+$/g);
const MAINNET_CAS_URLS = [
    'https://cas-internal.3boxlabs.com',
    'https://cas-direct.3boxlabs.com',
    'https://ceramic-prod-cas-api-gitcoin.3boxlabs.com',
    DEFAULT_ANCHOR_SERVICE_URLS[Networks.MAINNET],
];
export function makeAnchorServiceUrl(fromConfig, network, logger) {
    const casUrl = fromConfig?.replace(TRAILING_SLASH, '') || DEFAULT_ANCHOR_SERVICE_URLS[network];
    if (isMainnet(network) && !MAINNET_CAS_URLS.includes(casUrl)) {
        logger.warn(`${casUrl} is not a standard Anchor Service URL for Ceramic mainnet.  Use a custom anchor service URL at your own risk. Note than an unreliable Ceramic Anchor Service can lead to data loss.`);
    }
    return casUrl;
}
function isMainnet(network) {
    return network == Networks.MAINNET;
}
export async function usableAnchorChains(network, anchorService, logger) {
    const casChains = await anchorService.getSupportedChains();
    const casUrl = anchorService.url;
    const supportedChains = SUPPORTED_CHAINS_BY_NETWORK[network];
    const usableChains = supportedChains.filter((c) => casChains.includes(c));
    if (usableChains.length === 0) {
        throw new UnusableAnchorChainsError(network, casUrl, casChains, supportedChains);
    }
    logger.imp(`Connected to anchor service '${anchorService.url}' with supported anchor chains ['${usableChains.join("','")}']`);
    return usableChains;
}
export function makeAnchorServiceAuth(authMethod, anchorServiceUrl, network, logger, signer) {
    if (authMethod) {
        try {
            return new DIDAnchorServiceAuth(anchorServiceUrl, logger, signer);
        }
        catch (error) {
            throw new Error(`DID auth method for anchor service failed to instantiate`);
        }
    }
    else {
        if (isMainnet(network)) {
            logger.warn(`DEPRECATION WARNING: The default IP address authentication will soon be deprecated. Update your daemon config to use DID based authentication.`);
        }
        return null;
    }
}
export function makeAnchorService(config, ethereumRpcUrl, network, logger, versionInfo, signer) {
    if (network === Networks.INMEMORY) {
        return new InMemoryAnchorService(config, logger);
    }
    const anchorServiceUrl = makeAnchorServiceUrl(config.anchorServiceUrl, network, logger);
    if (!config.readOnly) {
        const anchorServiceAuth = makeAnchorServiceAuth(config.anchorServiceAuthMethod, anchorServiceUrl, network, logger, signer);
        if (anchorServiceAuth) {
            return new AuthenticatedEthereumAnchorService(anchorServiceAuth, anchorServiceUrl, ethereumRpcUrl, logger, versionInfo);
        }
    }
    return new EthereumAnchorService(anchorServiceUrl, ethereumRpcUrl, logger, versionInfo);
}
const DEFAULT_LOCAL_ETHEREUM_RPC = 'http://localhost:7545';
export function makeEthereumRpcUrl(fromConfig, network, logger) {
    if (!fromConfig && network == Networks.LOCAL) {
        return DEFAULT_LOCAL_ETHEREUM_RPC;
    }
    if (!fromConfig && isMainnet(network)) {
        logger.warn(`Running on mainnet without providing an ethereumRpcUrl is not recommended. Using the default ethereum provided may result in your requests being rate limited`);
    }
    return fromConfig;
}
//# sourceMappingURL=anchoring.js.map