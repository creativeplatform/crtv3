import { Networks } from '@ceramicnetwork/common';
import { randomUint32 } from '@stablelib/random';
const DEFAULT_NETWORK = Networks.INMEMORY;
const TOPIC_BY_NETWORK = {
    [Networks.MAINNET]: '/ceramic/mainnet',
    [Networks.TESTNET_CLAY]: '/ceramic/testnet-clay',
    [Networks.DEV_UNSTABLE]: '/ceramic/dev-unstable',
    [Networks.LOCAL]: `/ceramic/local-${randomUint32()}`,
    [Networks.INMEMORY]: `/ceramic/inmemory-${randomUint32()}`,
};
const ALLOW_CUSTOM_TOPIC = [Networks.INMEMORY, Networks.LOCAL];
export class CustomTopicError extends Error {
    constructor() {
        super("Specifying pub/sub topic is only supported for the 'inmemory' and 'local' networks");
    }
}
export class UnrecognizedNetworkError extends Error {
    constructor(network) {
        super(`Unrecognized Ceramic network name: '${network}'. Supported networks are: 'mainnet', 'testnet-clay', 'dev-unstable', 'local', 'inmemory'`);
    }
}
export function assertNetwork(input) {
    const isValid = Object.keys(TOPIC_BY_NETWORK).includes(input);
    if (!isValid)
        throw new UnrecognizedNetworkError(input);
}
export function pubsubTopicFromNetwork(network, customTopic) {
    if (customTopic && !ALLOW_CUSTOM_TOPIC.includes(network)) {
        throw new CustomTopicError();
    }
    return customTopic || TOPIC_BY_NETWORK[network];
}
export function networkOptionsByName(networkName = DEFAULT_NETWORK, customTopic, id = 0) {
    assertNetwork(networkName);
    const pubsubTopic = pubsubTopicFromNetwork(networkName, customTopic);
    if (id > 0 && networkName !== Networks.LOCAL) {
        throw Error('Cannot set network id for non-local networks');
    }
    return {
        name: networkName,
        pubsubTopic: pubsubTopic,
        id,
    };
}
//# sourceMappingURL=network-options.js.map