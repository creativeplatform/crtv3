import { DiagnosticsLogger, EventType, StreamMetadata, StreamState } from '@ceramicnetwork/common';
import { CommitID, StreamID } from '@ceramicnetwork/streamid';
import type { FeedAggregationStore, AggregationStoreEntry } from './store/feed-aggregation-store.js';
export declare class FeedDocument {
    readonly resumeToken: string;
    readonly commitId: CommitID;
    readonly content: any;
    readonly metadata: StreamMetadata;
    readonly eventType: EventType;
    constructor(resumeToken: string, commitId: CommitID, content: any, metadata: StreamMetadata, eventType: EventType);
    static fromStreamState(resumeToken: string, streamState: StreamState): FeedDocument;
}
export interface PublicFeed {
    aggregation: {
        documents: (after?: string) => ReadableStream<FeedDocument>;
    };
}
export declare class Feed implements PublicFeed {
    private readonly feedStore;
    private readonly logger;
    private readonly streamState;
    constructor(feedStore: FeedAggregationStore, logger: DiagnosticsLogger, streamState: (streamId: StreamID) => Promise<StreamState | undefined>);
    get aggregation(): {
        documents: any;
    };
    documents(after?: string): ReadableStream<FeedDocument>;
}
export declare class StreamLoadTransformer implements Transformer<AggregationStoreEntry, FeedDocument> {
    private readonly logger;
    private readonly streamState;
    constructor(logger: DiagnosticsLogger, streamState: (streamId: StreamID) => Promise<StreamState | undefined>);
    transform(entry: AggregationStoreEntry, controller: TransformStreamDefaultController<FeedDocument>): Promise<void>;
}
//# sourceMappingURL=feed.d.ts.map