import all from 'it-all';
import map from 'it-map';
class NotFoundError extends Error {
    constructor() {
        super(...arguments);
        this.notFound = true;
    }
}
function definiteSearchParams(obj) {
    return Object.keys(obj).reduce((acc, key) => obj[key] === undefined || obj[key] === null ? { ...acc } : { ...acc, [key]: obj[key] }, {});
}
export class LevelKVStore {
    constructor(level, logger) {
        this.level = level;
        this.logger = logger;
    }
    async init() {
        return;
    }
    batch() {
        return this.level.batch();
    }
    async close() {
        await this.level.close();
    }
    async del(key) {
        try {
            return await this.level.del(key);
        }
        catch (err) {
            const msg = `Error deleting key ${key} from leveldb state store: ${err}`;
            this.logger.warn(msg);
            throw new Error(msg);
        }
    }
    async get(key) {
        try {
            return await this.level.get(key);
        }
        catch (err) {
            const msg = `Error fetching key ${key} from leveldb state store: ${err}`;
            if (err.notFound) {
                throw new NotFoundError(msg);
            }
            else {
                this.logger.warn(msg);
                throw new Error(msg);
            }
        }
    }
    async isEmpty(params) {
        const keys = await this.findKeys(params);
        return keys.length === 0;
    }
    async exists(key) {
        try {
            const val = await this.get(key);
            return typeof val === 'string';
        }
        catch (e) {
            if (e.notFound) {
                return false;
            }
            else {
                throw e;
            }
        }
    }
    async find(params) {
        const searchParams = definiteSearchParams({
            keys: true,
            values: true,
            ...params,
        });
        return all(map(this.level.iterator(searchParams), (r) => {
            return {
                key: r[0],
                value: r[1],
            };
        }));
    }
    async findKeys(params) {
        const searchParams = definiteSearchParams({
            keys: true,
            values: false,
            ...params,
        });
        return all(map(this.level.iterator(searchParams), (r) => {
            return r[0];
        }));
    }
    async put(key, value) {
        try {
            await this.level.put(key, value);
        }
        catch (err) {
            const msg = `Error storing key ${key} to leveldb state store: ${err}`;
            this.logger.warn(msg);
            throw new Error(msg);
        }
    }
}
//# sourceMappingURL=level-kv-store.js.map