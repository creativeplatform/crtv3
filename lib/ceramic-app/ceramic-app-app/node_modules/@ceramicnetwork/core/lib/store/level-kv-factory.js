var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _LevelKVFactory_storeRoot, _LevelKVFactory_cache, _LevelKVFactory_createMutex, _LevelKVFactory_logger;
import { Networks } from '@ceramicnetwork/common';
import { join } from 'node:path';
import { access, mkdir } from 'node:fs/promises';
import { Mutex } from 'await-semaphore';
import { LevelKVStore } from './level-kv-store.js';
import { Level } from 'level';
export const ELP_NETWORK = 'elp';
export class LevelKVFactory {
    constructor(storeRoot, networkName, logger) {
        _LevelKVFactory_storeRoot.set(this, void 0);
        _LevelKVFactory_cache.set(this, void 0);
        _LevelKVFactory_createMutex.set(this, void 0);
        _LevelKVFactory_logger.set(this, void 0);
        this.networkName = networkName;
        __classPrivateFieldSet(this, _LevelKVFactory_storeRoot, storeRoot, "f");
        __classPrivateFieldSet(this, _LevelKVFactory_cache, new Map(), "f");
        __classPrivateFieldSet(this, _LevelKVFactory_createMutex, new Mutex(), "f");
        __classPrivateFieldSet(this, _LevelKVFactory_logger, logger, "f");
        this.open = this.open.bind(this);
    }
    create(useCaseName) {
        return __classPrivateFieldGet(this, _LevelKVFactory_createMutex, "f").use(async () => {
            const found = __classPrivateFieldGet(this, _LevelKVFactory_cache, "f").get(useCaseName);
            if (found)
                return found;
            const dirPath = await this.dirPath(useCaseName);
            const level = new Level(dirPath, { valueEncoding: 'json' });
            await level.open();
            const kv = new LevelKVStore(level, __classPrivateFieldGet(this, _LevelKVFactory_logger, "f"));
            __classPrivateFieldGet(this, _LevelKVFactory_cache, "f").set(useCaseName, kv);
            return kv;
        });
    }
    subDir(name, network = this.networkName) {
        if (name) {
            return `${network}-${name}`;
        }
        else {
            return network;
        }
    }
    async dirPath(useCaseName) {
        if (this.networkName === Networks.MAINNET) {
            const elpDir = this.subDir(useCaseName, ELP_NETWORK);
            const storePath = join(__classPrivateFieldGet(this, _LevelKVFactory_storeRoot, "f"), elpDir);
            const isPresent = await access(storePath)
                .then(() => true)
                .catch(() => false);
            if (isPresent) {
                __classPrivateFieldGet(this, _LevelKVFactory_logger, "f").warn(`LevelDB store ${useCaseName} found with ELP location, using it instead of default mainnet location`);
                return storePath;
            }
        }
        const subDir = this.subDir(useCaseName);
        const dirPath = join(__classPrivateFieldGet(this, _LevelKVFactory_storeRoot, "f"), subDir);
        await mkdir(dirPath, { recursive: true });
        return dirPath;
    }
    async open(name) {
        const found = __classPrivateFieldGet(this, _LevelKVFactory_cache, "f").get(name);
        if (found)
            return found;
        return this.create(name);
    }
    async close() {
        for (const store of __classPrivateFieldGet(this, _LevelKVFactory_cache, "f").values()) {
            await store.close();
        }
    }
}
_LevelKVFactory_storeRoot = new WeakMap(), _LevelKVFactory_cache = new WeakMap(), _LevelKVFactory_createMutex = new WeakMap(), _LevelKVFactory_logger = new WeakMap();
//# sourceMappingURL=level-kv-factory.js.map