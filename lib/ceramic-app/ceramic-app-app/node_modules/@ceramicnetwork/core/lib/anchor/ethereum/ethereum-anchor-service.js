var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _EthereumAnchorService_logger, _EthereumAnchorService_loop, _EthereumAnchorService_enableAnchorPollingLoop, _EthereumAnchorService_events, _EthereumAnchorService_anchorStoreQueue, _EthereumAnchorService_chainId, _EthereumAnchorService_store, _EthereumAnchorService_cas;
import { fetchJson } from '@ceramicnetwork/common';
import { AnchorRequestStatusName } from '@ceramicnetwork/common';
import { Subject } from 'rxjs';
import { EthereumAnchorValidator } from './ethereum-anchor-validator.js';
import { NotSingleChainError } from '../anchor-service.js';
import { AnchorProcessingLoop } from '../anchor-processing-loop.js';
import { RemoteCAS } from './remote-cas.js';
import { doNotWait } from '../../ancillary/do-not-wait.js';
import { NamedTaskQueue } from '../../state-management/named-task-queue.js';
const BATCH_SIZE = 1000;
export class EthereumAnchorService {
    constructor(anchorServiceUrl, ethereumRpcUrl, logger, versionInfo, sendRequest = fetchJson, enableAnchorPollingLoop = true) {
        _EthereumAnchorService_logger.set(this, void 0);
        _EthereumAnchorService_loop.set(this, void 0);
        _EthereumAnchorService_enableAnchorPollingLoop.set(this, void 0);
        _EthereumAnchorService_events.set(this, void 0);
        _EthereumAnchorService_anchorStoreQueue.set(this, void 0);
        _EthereumAnchorService_chainId.set(this, void 0);
        _EthereumAnchorService_store.set(this, void 0);
        _EthereumAnchorService_cas.set(this, void 0);
        __classPrivateFieldSet(this, _EthereumAnchorService_logger, logger, "f");
        __classPrivateFieldSet(this, _EthereumAnchorService_events, new Subject(), "f");
        __classPrivateFieldSet(this, _EthereumAnchorService_cas, new RemoteCAS(logger, anchorServiceUrl, sendRequest, versionInfo), "f");
        this.events = __classPrivateFieldGet(this, _EthereumAnchorService_events, "f");
        this.url = anchorServiceUrl;
        this.validator = new EthereumAnchorValidator(ethereumRpcUrl, logger);
        __classPrivateFieldSet(this, _EthereumAnchorService_enableAnchorPollingLoop, enableAnchorPollingLoop, "f");
        __classPrivateFieldSet(this, _EthereumAnchorService_anchorStoreQueue, new NamedTaskQueue((error) => {
            logger.err(error);
        }), "f");
    }
    async init(store, eventHandler) {
        __classPrivateFieldSet(this, _EthereumAnchorService_store, store, "f");
        const supportedChains = await __classPrivateFieldGet(this, _EthereumAnchorService_cas, "f").supportedChains();
        if (supportedChains.length !== 1) {
            throw new NotSingleChainError();
        }
        __classPrivateFieldSet(this, _EthereumAnchorService_chainId, supportedChains[0], "f");
        await this.validator.init(__classPrivateFieldGet(this, _EthereumAnchorService_chainId, "f"));
        __classPrivateFieldSet(this, _EthereumAnchorService_loop, new AnchorProcessingLoop(BATCH_SIZE, __classPrivateFieldGet(this, _EthereumAnchorService_cas, "f"), __classPrivateFieldGet(this, _EthereumAnchorService_store, "f"), __classPrivateFieldGet(this, _EthereumAnchorService_logger, "f"), eventHandler, __classPrivateFieldGet(this, _EthereumAnchorService_anchorStoreQueue, "f")), "f");
        if (__classPrivateFieldGet(this, _EthereumAnchorService_enableAnchorPollingLoop, "f")) {
            __classPrivateFieldGet(this, _EthereumAnchorService_loop, "f").start();
        }
    }
    assertCASAccessible() {
        __classPrivateFieldGet(this, _EthereumAnchorService_cas, "f").assertCASAccessible();
    }
    async getSupportedChains() {
        return [__classPrivateFieldGet(this, _EthereumAnchorService_chainId, "f")];
    }
    async requestAnchor(streamId, tip) {
        const now = new Date();
        await __classPrivateFieldGet(this, _EthereumAnchorService_anchorStoreQueue, "f").run(streamId.toString(), () => __classPrivateFieldGet(this, _EthereumAnchorService_store, "f").save(streamId, {
            cid: tip,
            timestamp: now.getTime(),
        }));
        doNotWait(__classPrivateFieldGet(this, _EthereumAnchorService_cas, "f").createRequest(streamId, tip, now), __classPrivateFieldGet(this, _EthereumAnchorService_logger, "f"));
        return {
            status: AnchorRequestStatusName.PENDING,
            streamId: streamId,
            cid: tip,
            message: 'Sending anchoring request',
        };
    }
    async close() {
        __classPrivateFieldGet(this, _EthereumAnchorService_logger, "f").debug(`Closing EthereumAnchorService`);
        await __classPrivateFieldGet(this, _EthereumAnchorService_cas, "f")?.close();
        await __classPrivateFieldGet(this, _EthereumAnchorService_store, "f")?.close();
        await __classPrivateFieldGet(this, _EthereumAnchorService_loop, "f")?.stop();
    }
}
_EthereumAnchorService_logger = new WeakMap(), _EthereumAnchorService_loop = new WeakMap(), _EthereumAnchorService_enableAnchorPollingLoop = new WeakMap(), _EthereumAnchorService_events = new WeakMap(), _EthereumAnchorService_anchorStoreQueue = new WeakMap(), _EthereumAnchorService_chainId = new WeakMap(), _EthereumAnchorService_store = new WeakMap(), _EthereumAnchorService_cas = new WeakMap();
export class AuthenticatedEthereumAnchorService extends EthereumAnchorService {
    constructor(auth, anchorServiceUrl, ethereumRpcUrl, logger, versionInfo, enableAnchorPollingLoop = true) {
        super(anchorServiceUrl, ethereumRpcUrl, logger, versionInfo, auth.sendAuthenticatedRequest.bind(auth), enableAnchorPollingLoop);
        this.auth = auth;
    }
    async init(store, eventHandler) {
        await this.auth.init();
        await super.init(store, eventHandler);
    }
}
//# sourceMappingURL=ethereum-anchor-service.js.map