import type { AnchorEvent, FetchRequest, DiagnosticsLogger } from '@ceramicnetwork/common';
import { type Observable } from 'rxjs';
import type { AnchorService, AnchorServiceAuth, AnchorValidator, AuthenticatedAnchorService } from '../anchor-service.js';
import type { AnchorRequestStore } from '../../store/anchor-request-store.js';
import { type AnchorLoopHandler } from '../anchor-service.js';
import { StreamID } from '@ceramicnetwork/streamid';
import { CID } from 'multiformats/cid';
import { VersionInfo } from '../../ceramic.js';
export declare class EthereumAnchorService implements AnchorService {
    #private;
    readonly url: string;
    readonly events: Observable<AnchorEvent>;
    readonly validator: AnchorValidator;
    constructor(anchorServiceUrl: string, ethereumRpcUrl: string | undefined, logger: DiagnosticsLogger, versionInfo: VersionInfo, sendRequest?: FetchRequest, enableAnchorPollingLoop?: boolean);
    init(store: AnchorRequestStore, eventHandler: AnchorLoopHandler): Promise<void>;
    assertCASAccessible(): void;
    getSupportedChains(): Promise<Array<string>>;
    requestAnchor(streamId: StreamID, tip: CID): Promise<AnchorEvent>;
    close(): Promise<void>;
}
export declare class AuthenticatedEthereumAnchorService extends EthereumAnchorService implements AuthenticatedAnchorService {
    readonly auth: AnchorServiceAuth;
    constructor(auth: AnchorServiceAuth, anchorServiceUrl: string, ethereumRpcUrl: string | undefined, logger: DiagnosticsLogger, versionInfo: VersionInfo, enableAnchorPollingLoop?: boolean);
    init(store: AnchorRequestStore, eventHandler: AnchorLoopHandler): Promise<void>;
}
//# sourceMappingURL=ethereum-anchor-service.d.ts.map