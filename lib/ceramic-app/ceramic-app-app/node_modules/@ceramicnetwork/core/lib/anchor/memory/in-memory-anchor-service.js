var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _InMemoryAnchorService_signer, _InMemoryAnchorService_cas, _InMemoryAnchorService_logger, _InMemoryAnchorService_enableAnchorPollingLoop, _InMemoryAnchorService_anchorStoreQueue, _InMemoryAnchorService_loop, _InMemoryAnchorService_store;
import { AnchorRequestStatusName, } from '@ceramicnetwork/common';
import { InMemoryAnchorValidator } from './in-memory-anchor-validator.js';
import { InMemoryCAS } from './in-memory-cas.js';
import { AnchorProcessingLoop } from '../anchor-processing-loop.js';
import { doNotWait } from '../../ancillary/do-not-wait.js';
import { NamedTaskQueue } from '../../state-management/named-task-queue.js';
import { LRUCache } from 'least-recent';
const CHAIN_ID = 'inmemory:12345';
const BATCH_SIZE = 10;
export const TRANSACTION_CACHE = new LRUCache(100);
export class InMemoryAnchorService {
    constructor(_config = {}, logger) {
        _InMemoryAnchorService_signer.set(this, void 0);
        _InMemoryAnchorService_cas.set(this, void 0);
        _InMemoryAnchorService_logger.set(this, void 0);
        _InMemoryAnchorService_enableAnchorPollingLoop.set(this, void 0);
        _InMemoryAnchorService_anchorStoreQueue.set(this, void 0);
        _InMemoryAnchorService_loop.set(this, void 0);
        _InMemoryAnchorService_store.set(this, void 0);
        this.url = '<inmemory>';
        __classPrivateFieldSet(this, _InMemoryAnchorService_store, undefined, "f");
        this.transactionCache = TRANSACTION_CACHE;
        this.validator = new InMemoryAnchorValidator(CHAIN_ID, this.transactionCache);
        __classPrivateFieldSet(this, _InMemoryAnchorService_cas, new InMemoryCAS(CHAIN_ID, this.transactionCache, _config.anchorOnRequest ?? true), "f");
        __classPrivateFieldSet(this, _InMemoryAnchorService_logger, logger, "f");
        __classPrivateFieldSet(this, _InMemoryAnchorService_enableAnchorPollingLoop, _config.enableAnchorPollingLoop ?? true, "f");
        __classPrivateFieldSet(this, _InMemoryAnchorService_anchorStoreQueue, new NamedTaskQueue((error) => {
            logger.err(error);
        }), "f");
    }
    async init(store, eventHandler) {
        __classPrivateFieldSet(this, _InMemoryAnchorService_store, store, "f");
        __classPrivateFieldSet(this, _InMemoryAnchorService_loop, new AnchorProcessingLoop(BATCH_SIZE, __classPrivateFieldGet(this, _InMemoryAnchorService_cas, "f"), __classPrivateFieldGet(this, _InMemoryAnchorService_store, "f"), __classPrivateFieldGet(this, _InMemoryAnchorService_logger, "f"), eventHandler, __classPrivateFieldGet(this, _InMemoryAnchorService_anchorStoreQueue, "f")), "f");
        if (__classPrivateFieldGet(this, _InMemoryAnchorService_enableAnchorPollingLoop, "f")) {
            __classPrivateFieldGet(this, _InMemoryAnchorService_loop, "f").start();
        }
    }
    assertCASAccessible() {
        __classPrivateFieldGet(this, _InMemoryAnchorService_cas, "f").assertCASAccessible();
    }
    getSupportedChains() {
        return __classPrivateFieldGet(this, _InMemoryAnchorService_cas, "f").supportedChains();
    }
    async anchor() {
        __classPrivateFieldGet(this, _InMemoryAnchorService_cas, "f").anchor();
    }
    moveAnchors(from, to, reset = false) {
        if (Array.isArray(from)) {
            for (const fromStatus of from) {
                __classPrivateFieldGet(this, _InMemoryAnchorService_cas, "f").moveAnchors(fromStatus, to, reset);
            }
        }
        else {
            __classPrivateFieldGet(this, _InMemoryAnchorService_cas, "f").moveAnchors(from, to, reset);
        }
    }
    set signer(signer) {
        __classPrivateFieldSet(this, _InMemoryAnchorService_signer, signer, "f");
    }
    async requestAnchor(streamId, tip) {
        const now = new Date();
        await __classPrivateFieldGet(this, _InMemoryAnchorService_anchorStoreQueue, "f").run(streamId.toString(), () => __classPrivateFieldGet(this, _InMemoryAnchorService_store, "f").save(streamId, {
            cid: tip,
            timestamp: now.getTime(),
        }));
        doNotWait(__classPrivateFieldGet(this, _InMemoryAnchorService_cas, "f").createRequest(streamId, tip, now), __classPrivateFieldGet(this, _InMemoryAnchorService_logger, "f"));
        return {
            status: AnchorRequestStatusName.PENDING,
            streamId: streamId,
            cid: tip,
            message: 'Sending anchoring request',
        };
    }
    async disableAnchorProcessingLoop() {
        return __classPrivateFieldGet(this, _InMemoryAnchorService_loop, "f").stop();
    }
    async close() {
        await __classPrivateFieldGet(this, _InMemoryAnchorService_cas, "f").close();
        await __classPrivateFieldGet(this, _InMemoryAnchorService_store, "f").close();
        await __classPrivateFieldGet(this, _InMemoryAnchorService_loop, "f").stop();
    }
}
_InMemoryAnchorService_signer = new WeakMap(), _InMemoryAnchorService_cas = new WeakMap(), _InMemoryAnchorService_logger = new WeakMap(), _InMemoryAnchorService_enableAnchorPollingLoop = new WeakMap(), _InMemoryAnchorService_anchorStoreQueue = new WeakMap(), _InMemoryAnchorService_loop = new WeakMap(), _InMemoryAnchorService_store = new WeakMap();
//# sourceMappingURL=in-memory-anchor-service.js.map