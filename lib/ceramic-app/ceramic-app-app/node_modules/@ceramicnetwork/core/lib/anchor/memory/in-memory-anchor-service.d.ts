import type { AnchorEvent, CeramicSigner } from '@ceramicnetwork/common';
import { type NotCompleteStatusName, type DiagnosticsLogger } from '@ceramicnetwork/common';
import type { AnchorLoopHandler, AnchorService, AnchorValidator } from '../anchor-service.js';
import type { AnchorRequestStore } from '../../store/anchor-request-store.js';
import { LRUCache } from 'least-recent';
import { StreamID } from '@ceramicnetwork/streamid';
import { CID } from 'multiformats/cid';
export declare const TRANSACTION_CACHE: LRUCache<string, number>;
declare type InMemoryAnchorConfig = {
    anchorDelay: number;
    anchorOnRequest: boolean;
    enableAnchorPollingLoop: boolean;
};
export declare class InMemoryAnchorService implements AnchorService {
    #private;
    private readonly transactionCache;
    readonly url = "<inmemory>";
    readonly validator: AnchorValidator;
    constructor(_config: Partial<InMemoryAnchorConfig>, logger: DiagnosticsLogger);
    init(store: AnchorRequestStore, eventHandler: AnchorLoopHandler): Promise<void>;
    assertCASAccessible(): void;
    getSupportedChains(): Promise<Array<string>>;
    anchor(): Promise<void>;
    moveAnchors(from: NotCompleteStatusName | Array<NotCompleteStatusName>, to: NotCompleteStatusName, reset?: boolean): void;
    set signer(signer: CeramicSigner);
    requestAnchor(streamId: StreamID, tip: CID): Promise<AnchorEvent>;
    disableAnchorProcessingLoop(): Promise<void>;
    close(): Promise<void>;
}
export {};
//# sourceMappingURL=in-memory-anchor-service.d.ts.map