import { StreamUtils } from '@ceramicnetwork/common';
export class FeedDocument {
    constructor(resumeToken, commitId, content, metadata, eventType) {
        this.resumeToken = resumeToken;
        this.commitId = commitId;
        this.content = content;
        this.metadata = metadata;
        this.eventType = eventType;
    }
    static fromStreamState(resumeToken, streamState) {
        return new FeedDocument(resumeToken, StreamUtils.commitIdFromStreamState(streamState), streamState.next ? streamState.next.content : streamState.content, streamState.next ? streamState.next.metadata : streamState.metadata, streamState.log[streamState.log.length - 1].type);
    }
}
export class Feed {
    constructor(feedStore, logger, streamState) {
        this.feedStore = feedStore;
        this.logger = logger;
        this.streamState = streamState;
    }
    get aggregation() {
        return {
            documents: this.documents.bind(this),
        };
    }
    documents(after) {
        const transformer = new StreamLoadTransformer(this.logger, this.streamState);
        return this.feedStore.streamIDs(after).pipeThrough(new TransformStream(transformer));
    }
}
export class StreamLoadTransformer {
    constructor(logger, streamState) {
        this.logger = logger;
        this.streamState = streamState;
    }
    async transform(entry, controller) {
        const found = await this.streamState(entry.streamID);
        if (found) {
            const feedDocument = FeedDocument.fromStreamState(entry.resumeToken, found);
            controller.enqueue(feedDocument);
        }
        else {
            this.logger.warn(`Can not send ${entry.streamID} to feed: not found in memory or store`);
        }
    }
}
//# sourceMappingURL=feed.js.map