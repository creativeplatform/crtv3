import { Dispatcher } from './dispatcher.js';
import { StreamID, CommitID, StreamRef } from '@ceramicnetwork/streamid';
import { IpfsTopology } from '@ceramicnetwork/ipfs-topology';
import { CreateOpts, Stream, StreamHandler, LoadOpts, CeramicCommit, IpfsApi, MultiQuery, PinningBackendStatic, LoggerProvider, UpdateOpts, SyncOptions, AnchorStatus, StreamState, AdminApi, NodeStatusResponse, AnchorOpts, CeramicSigner, StreamStateLoader, StreamReaderWriter } from '@ceramicnetwork/common';
import { DID } from 'dids';
import { PinStoreFactory } from './store/pin-store-factory.js';
import { Repository } from './state-management/repository.js';
import { HandlersMap } from './handlers-map.js';
import { type IndexingConfig, LocalIndexApi } from '@ceramicnetwork/indexing';
import { ShutdownSignal } from './shutdown-signal.js';
import { ProvidersCache } from './providers-cache.js';
import { type CeramicNetworkOptions } from './initialization/network-options.js';
import type { AnchorService } from './anchor/anchor-service.js';
import { Feed, type PublicFeed } from './feed.js';
import { IReconApi } from './recon.js';
export declare const DEFAULT_STATE_STORE_DIRECTORY: string;
export interface CeramicConfig {
    ethereumRpcUrl?: string;
    anchorServiceUrl?: string;
    anchorServiceAuthMethod?: string;
    stateStoreDirectory?: string;
    ipfsPinningEndpoints?: string[];
    pinningBackends?: PinningBackendStatic[];
    loggerProvider?: LoggerProvider;
    readOnly?: boolean;
    indexing?: IndexingConfig;
    metrics?: MetricsConfig;
    networkName?: string;
    pubsubTopic?: string;
    streamCacheLimit?: number;
    concurrentRequestsLimit?: number;
    useCentralizedPeerDiscovery?: boolean;
    syncOverride?: SyncOptions;
    disablePeerDataSync?: boolean;
    networkId?: number;
    [index: string]: any;
}
export interface CeramicModules {
    anchorService: AnchorService | null;
    dispatcher: Dispatcher;
    ipfs: IpfsApi;
    ipfsTopology: IpfsTopology;
    loggerProvider: LoggerProvider;
    pinStoreFactory: PinStoreFactory;
    repository: Repository;
    shutdownSignal: ShutdownSignal;
    providersCache: ProvidersCache;
    feed: Feed;
    signer: CeramicSigner;
    reconApi: IReconApi;
}
export interface VersionInfo {
    cliPackageVersion: string;
    gitHash: string;
    ceramicOneVersion: string;
}
interface MetricsConfig {
    prometheusExporterEnabled?: boolean;
    prometheusExporterPort?: number;
    metricsExporterEnabled?: boolean;
    collectorHost?: string;
    metricsPublisherEnabled?: boolean;
    metricsPublishIntervalMS?: number;
}
export interface CeramicParameters {
    readOnly: boolean;
    stateStoreDirectory?: string;
    indexingConfig: IndexingConfig;
    sync?: boolean;
    networkOptions: CeramicNetworkOptions;
    loadOptsOverride: LoadOpts;
    anchorLoopMinDurationMs?: number;
    versionInfo?: VersionInfo;
    metrics?: MetricsConfig;
}
export declare class Ceramic implements StreamReaderWriter, StreamStateLoader {
    private _did?;
    private _ipfs?;
    private _signer;
    readonly dispatcher: Dispatcher;
    readonly loggerProvider: LoggerProvider;
    readonly admin: AdminApi;
    readonly feed: PublicFeed;
    readonly repository: Repository;
    readonly anchorService: AnchorService;
    private readonly providersCache;
    private readonly syncApi;
    readonly _streamHandlers: HandlersMap;
    private readonly _readOnly;
    private readonly _ipfsTopology;
    private readonly _logger;
    private readonly _metricsConfig;
    private readonly _networkOptions;
    private _supportedChains;
    private readonly _loadOptsOverride;
    private readonly _shutdownSignal;
    private readonly _kvFactory;
    private readonly _runId;
    private readonly _startTime;
    private readonly _versionInfo;
    private _versionMetricInterval;
    constructor(modules: CeramicModules, params: CeramicParameters);
    get index(): LocalIndexApi;
    get pubsubTopic(): string;
    get signer(): CeramicSigner;
    get ipfs(): IpfsApi;
    get did(): DID | undefined;
    set did(did: DID);
    static _processConfig(ipfs: IpfsApi, config: CeramicConfig, versionInfo: VersionInfo): [CeramicModules, CeramicParameters];
    static create(ipfs: IpfsApi, config: CeramicConfig, versionInfo: VersionInfo): Promise<Ceramic>;
    _init(doPeerDiscovery: boolean): Promise<void>;
    _publishVersionMetrics(): Promise<void>;
    _startMetrics(): Promise<void>;
    _startupChecks(): Promise<void>;
    _checkIPFSPersistence(): Promise<void>;
    addStreamHandler<T extends Stream>(streamHandler: StreamHandler<T>): void;
    nodeStatus(): Promise<NodeStatusResponse>;
    applyCommit<T extends Stream>(streamId: string | StreamID, commit: CeramicCommit, opts?: UpdateOpts): Promise<T>;
    requestAnchor(streamId: string | StreamID, opts?: LoadOpts & AnchorOpts): Promise<AnchorStatus>;
    createStreamFromGenesis<T extends Stream>(type: number, genesis: any, opts?: CreateOpts): Promise<T>;
    loadStream<T extends Stream>(streamId: StreamID | CommitID | string, opts?: LoadOpts): Promise<T>;
    loadStreamState(streamId: StreamID): Promise<StreamState | undefined>;
    _ensureGenesis(genesis: CeramicCommit, streamRef: StreamRef, opts: LoadOpts): Promise<void>;
    private _loadLinkedStreams;
    multiQuery(queries: Array<MultiQuery>, timeout?: number): Promise<Record<string, Stream>>;
    loadStreamCommits(streamId: string | StreamID): Promise<Record<string, any>[]>;
    getSupportedChains(): Promise<Array<string>>;
    buildStreamFromState<T extends Stream = Stream>(state: StreamState): T;
    close(): Promise<void>;
}
export {};
//# sourceMappingURL=ceramic.d.ts.map