import { LoggerProvider } from '@ceramicnetwork/common';
import tmp from 'tmp-promise';
import { Dispatcher } from '../dispatcher.js';
import { StreamStateStore } from '../store/stream-state-store.js';
import { Repository } from '../state-management/repository.js';
import { ShutdownSignal } from '../shutdown-signal.js';
import { TaskQueue } from '../ancillary/task-queue.js';
import { LevelKVFactory } from '../store/level-kv-factory.js';
export async function createDispatcher(ipfs, pubsubTopic) {
    const loggerProvider = new LoggerProvider();
    const logger = loggerProvider.getDiagnosticsLogger();
    const levelPath = await tmp.tmpName();
    const factory = new LevelKVFactory(levelPath, 'test', logger);
    const stateStore = new StreamStateStore();
    await stateStore.open(factory);
    const fauxReconApi = {
        init: () => Promise.resolve(),
        pipe: () => fauxReconApi,
        subscribe: () => fauxReconApi,
    };
    const repository = new Repository(100, 100, fauxReconApi, logger);
    const pinStore = {
        stateStore,
        open: () => Promise.resolve(),
    };
    const anchorRequestStore = {
        open: () => Promise.resolve(),
    };
    const index = {
        init: () => Promise.resolve(),
        indexedModels: () => [],
    };
    repository.setDeps({
        pinStore,
        kvFactory: factory,
        anchorRequestStore,
        indexing: index,
    });
    await repository.init();
    const shutdownSignal = new ShutdownSignal();
    return new Dispatcher(ipfs, pubsubTopic, repository, logger, loggerProvider.makeServiceLogger('pubsub'), shutdownSignal, true, 10, fauxReconApi, new TaskQueue());
}
//# sourceMappingURL=create-dispatcher.js.map