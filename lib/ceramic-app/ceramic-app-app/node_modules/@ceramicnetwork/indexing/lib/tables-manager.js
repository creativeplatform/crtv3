import { ColumnType, createConfigTable, createPostgresIndices, createPostgresModelTable, createSqliteIndices, createSqliteModelTable, DatabaseType, defaultIndices, migrateConfigTable, } from './migrations/1-create-model-table.js';
import { asTableName } from './as-table-name.util.js';
import { Model } from '@ceramicnetwork/stream-model';
import { fieldsIndexName, INDEXED_MODEL_CONFIG_TABLE_NAME, MODEL_IMPLEMENTS_TABLE_NAME, } from './database-index-api.js';
import { STRUCTURES } from './migrations/cdb-schema-verification.js';
import { CONFIG_TABLE_NAME } from './config.js';
import { addColumnPrefix } from './column-name.util.js';
function relationsDefinitionsToColumnInfo(relations) {
    if (!relations) {
        return [];
    }
    return Object.keys(relations).map((keyName) => {
        return { name: addColumnPrefix(keyName), type: ColumnType.STRING };
    });
}
export class TablesManager {
    constructor(dbType, dataSource, logger) {
        this.dbType = dbType;
        this.dataSource = dataSource;
        this.logger = logger;
    }
    async listMidTables() {
        throw new Error('Must be implemented in extending class');
    }
    async initMidTables(_modelsToIndex) {
        throw new Error('Must be implemented in extending class');
    }
    async assertHasMidIndices(_tableName, _args) {
        throw new Error('Must be implemented in extending class');
    }
    hasJsonBSupport() {
        throw new Error('Must be implemented in extending class');
    }
    listConfigTables() {
        return [
            {
                tableName: INDEXED_MODEL_CONFIG_TABLE_NAME,
                validSchema: STRUCTURES[this.dbType].CONFIG_TABLE_MODEL_INDEX,
            },
            { tableName: CONFIG_TABLE_NAME, validSchema: STRUCTURES[this.dbType].CONFIG_TABLE },
            {
                tableName: MODEL_IMPLEMENTS_TABLE_NAME,
                validSchema: STRUCTURES[this.dbType].MODEL_IMPLEMENTS_TABLE,
            },
        ];
    }
    async initConfigTables(network) {
        const configTables = this.listConfigTables();
        await Promise.all(configTables.map(async (table) => {
            await this.initConfigTable(table, network);
        }));
    }
    async initConfigTable(table, network) {
        const exists = await this.dataSource.schema.hasTable(table.tableName);
        if (!exists) {
            this.logger.imp(`Creating ComposeDB config table: ${table.tableName}`);
            await createConfigTable(this.dataSource, table.tableName, network, this.hasJsonBSupport());
        }
        else {
            await migrateConfigTable(this.dataSource, table.tableName, this.hasJsonBSupport());
            if (table.tableName === CONFIG_TABLE_NAME) {
                const config = await this.dataSource
                    .from(table.tableName)
                    .where('option', 'network')
                    .first('value');
                if (config.value !== network) {
                    throw new Error(`Initialization failed for config table: ${table.tableName}. The database is configured to use the network ${config.value} but the current network is ${network}.`);
                }
            }
        }
    }
    async _verifyConfigTables() {
        const configTables = this.listConfigTables();
        await Promise.all(configTables.map(async (configTable) => {
            await this._verifyConfigTable(configTable);
        }));
    }
    async _verifyConfigTable(table) {
        const columns = await this.dataSource.table(table.tableName).columnInfo();
        const validSchema = JSON.stringify(table.validSchema);
        const actualSchema = JSON.stringify(columns);
        if (validSchema != actualSchema) {
            throw new Error(`Schema verification failed for config table: ${table.tableName}. Please make sure node has been setup correctly.
    Expected=${JSON.stringify(validSchema)}
    Actual=${JSON.stringify(actualSchema)}
        `);
        }
    }
    async _verifyMidTables(modelsToIndex) {
        const tableNames = await this.listMidTables();
        await Promise.all(tableNames.map(async (tableName) => {
            await this._verifyMidTable(tableName, modelsToIndex);
        }));
    }
    async _verifyMidTable(tableName, modelsToIndex) {
        const modelIndexArgs = modelsToIndex.find((model) => tableName == asTableName(model.model));
        if (!modelIndexArgs) {
            return;
        }
        const expectedTableStructure = Object.assign({}, STRUCTURES[this.dbType].COMMON_TABLE);
        if (modelIndexArgs.relations) {
            for (const relation of Object.keys(modelIndexArgs.relations)) {
                expectedTableStructure[addColumnPrefix(relation)] = STRUCTURES[this.dbType].RELATION_COLUMN;
            }
        }
        const validSchema = JSON.stringify(expectedTableStructure);
        const columns = await this.dataSource.table(tableName).columnInfo();
        const actualSchema = JSON.stringify(columns);
        if (validSchema != actualSchema) {
            throw new Error(`Schema verification failed for index: ${tableName}. Please make sure latest migrations have been applied.
    Expected=${JSON.stringify(validSchema)}
    Actual=${JSON.stringify(actualSchema)}
        `);
        }
        await this.assertHasMidIndices(tableName, modelIndexArgs);
    }
    async verifyTables(modelsToIndex) {
        await Promise.all([this._verifyConfigTables(), this._verifyMidTables(modelsToIndex)]);
    }
    validateIndices(tableName, expect, actual) {
        const missingIndices = expect.filter((indexName) => {
            return !actual.includes(indexName);
        });
        if (missingIndices.length > 0) {
            throw new Error(`Schema verification failed for index: ${tableName}. Please make sure latest migrations have been applied.
          Missing Indices=${JSON.stringify(missingIndices)}
          Actual=${JSON.stringify(actual)}`);
        }
    }
}
export class PostgresTablesManager extends TablesManager {
    constructor(dataSource, logger) {
        super(DatabaseType.POSTGRES, dataSource, logger);
    }
    async listMidTables() {
        const result = await this.dataSource
            .select('tablename')
            .from('pg_tables')
            .andWhere((q) => q.whereLike('tablename', 'kjz%').orWhere('tablename', Model.MODEL.toString()));
        return result.map((value) => value.tablename);
    }
    async initMidTables(modelsToIndex) {
        await Promise.all(modelsToIndex.map(async (modelIndexArgs) => {
            await this.initMidTable(modelIndexArgs);
        }));
    }
    async initMidTable(modelIndexArgs) {
        const tableName = asTableName(modelIndexArgs.model);
        if (tableName.length > 63) {
            const errStr = `Cannot index model ${modelIndexArgs.model.toString()}.  Table name is too long: ${tableName}`;
            this.logger.err(errStr);
            throw new Error(errStr);
        }
        const relationColumns = relationsDefinitionsToColumnInfo(modelIndexArgs.relations);
        const exists = await this.dataSource.schema.hasTable(tableName);
        if (!exists) {
            this.logger.imp(`Creating ComposeDB Indexing table for model: ${tableName}`);
            await createPostgresModelTable(this.dataSource, tableName, relationColumns);
            if (modelIndexArgs.indices) {
                await createPostgresIndices(this.dataSource, tableName, modelIndexArgs.indices);
            }
        }
        else if (relationColumns.length) {
            const columnNamesToChange = [];
            for (const column of relationColumns) {
                if (column.type === ColumnType.STRING) {
                    const columnName = addColumnPrefix(column.name);
                    const isColumnPresent = await this.dataSource.schema.hasColumn(tableName, columnName);
                    if (isColumnPresent)
                        columnNamesToChange.push(columnName);
                }
            }
            await this.dataSource.schema.alterTable(tableName, (table) => {
                for (const columnName of columnNamesToChange) {
                    table.string(columnName, 1024).nullable().alter();
                }
            });
        }
    }
    async assertHasMidIndices(tableName, args) {
        const expectedIndices = defaultIndices(tableName).indices.flatMap((index) => index.name);
        if (args && args.indices) {
            for (const index of args.indices) {
                expectedIndices.push(fieldsIndexName(index, tableName).toLowerCase());
            }
        }
        const indicesResult = await this.dataSource.raw(`
select *
from pg_indexes
where tablename like '${tableName}'
    `);
        const actualIndices = indicesResult ? indicesResult.rows.map((row) => row.indexname) : [];
        this.validateIndices(tableName, expectedIndices, actualIndices);
    }
    hasJsonBSupport() {
        return true;
    }
}
export class SqliteTablesManager extends TablesManager {
    constructor(dataSource, logger) {
        super(DatabaseType.SQLITE, dataSource, logger);
    }
    async listMidTables() {
        const result = await this.dataSource
            .from('sqlite_schema')
            .select('name')
            .whereIn('type', ['table'])
            .andWhere((q) => q.whereLike('name', 'kjz%').orWhere('name', Model.MODEL.toString()));
        return result.map((r) => r.name);
    }
    async initMidTables(modelsToIndex) {
        const existingTables = await this.listMidTables();
        await Promise.all(modelsToIndex.map(async (modelIndexArgs) => {
            await this.initMidTable(modelIndexArgs, existingTables);
        }));
    }
    async initMidTable(modelIndexArgs, existingTables) {
        const tableName = asTableName(modelIndexArgs.model);
        const relationColumns = relationsDefinitionsToColumnInfo(modelIndexArgs.relations);
        if (existingTables.includes(tableName)) {
            if (relationColumns.length) {
                const columnNamesToChange = [];
                for (const column of relationColumns) {
                    if (column.type === ColumnType.STRING) {
                        const columnName = addColumnPrefix(column.name);
                        const isColumnPresent = await this.dataSource.schema.hasColumn(tableName, columnName);
                        if (isColumnPresent)
                            columnNamesToChange.push(columnName);
                    }
                }
                await this.dataSource.schema.alterTable(tableName, (table) => {
                    for (const columnName of columnNamesToChange) {
                        table.string(columnName, 1024).nullable().alter();
                    }
                });
            }
            return;
        }
        this.logger.imp(`Creating ComposeDB Indexing table for model: ${tableName}`);
        await createSqliteModelTable(this.dataSource, tableName, relationColumns);
        if (modelIndexArgs.indices) {
            await createSqliteIndices(this.dataSource, tableName, modelIndexArgs.indices);
        }
    }
    async assertHasMidIndices(tableName, args) {
        const expectedIndices = defaultIndices(tableName).indices.flatMap((index) => index.name);
        if (args && args.indices) {
            for (const index of args.indices) {
                expectedIndices.push(fieldsIndexName(index, tableName));
            }
        }
        const indicesResult = await this.dataSource.raw(`
select name, tbl_name
FROM sqlite_master
WHERE type='index'
and tbl_name like '${tableName}'
;
  `);
        const actualIndices = indicesResult ? indicesResult.map((row) => row.name) : [];
        this.validateIndices(tableName, expectedIndices, actualIndices);
    }
    hasJsonBSupport() {
        return false;
    }
}
//# sourceMappingURL=tables-manager.js.map