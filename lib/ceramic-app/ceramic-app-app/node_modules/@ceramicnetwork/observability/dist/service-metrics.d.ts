import { type TimeInput } from '@opentelemetry/api';
export declare const UNKNOWN_CALLER = "Unknown";
export declare const CONCURRENCY_LIMIT = 1;
export declare const TRACE_CONCURRENCY_LIMIT = 1;
export declare const DEFAULT_TRACE_SAMPLE_RATIO = 0.1;
export declare const DEFAULT_EXPORT_INTERVAL_MS = 60000;
export declare const DEFAULT_EXPORT_TIMEOUT_MS = 30000;
interface Endable {
    end(endTime?: TimeInput): void;
}
interface Timeable {
    createdAt?: Date;
    updatedAt?: Date;
    timestamp?: Number | Date;
}
export declare enum SinceField {
    CREATED_AT = 0,
    UPDATED_AT = 1,
    TIMESTAMP = 2
}
export declare class TimeableMetric {
    protected cnt: number;
    protected totTime: number;
    protected maxTime: number;
    protected since: SinceField;
    protected name: string | null;
    private publishIntervalId;
    private publishIntervalMS;
    constructor(since: SinceField, name?: string, interval?: number);
    recordAll(tasks: Timeable[]): void;
    record(task: Timeable): void;
    private getMeanTime;
    publishStats(name?: string): void;
    startPublishingStats(): void;
    stopPublishingStats(): void;
}
declare class _ServiceMetrics {
    protected caller: any;
    protected readonly counters: any;
    protected readonly gauges: any;
    protected readonly histograms: any;
    protected readonly observations: any;
    protected meter: any;
    protected meterProvider: any;
    protected tracer: any;
    protected logger: any;
    protected append_total_to_counters: any;
    protected instanceId: any;
    private static instance;
    private constructor();
    static getInstance(): _ServiceMetrics;
    start(collectorHost?: string, caller?: string, sample_ratio?: number, logger?: any, append_total_to_counters?: boolean, prometheusExportPort?: number, exportIntervalMillis?: number, exportTimeoutMillis?: number): boolean;
    shutdown(): Promise<void>;
    setInstanceIdentifier(instanceId: string): void;
    adjustParams(params?: any): any;
    startSpan(name: string, params?: any): Endable;
    count(name: string, value: number, params?: any): void;
    observe(name: string, value: number, params?: any): void;
    record(name: string, value: number, params?: any): void;
    recordAverage(name: string, arr: number[]): void;
    recordObjectFields(prefix: string, obj: object): void;
    recordRatio(name: string, numer: number, denom: number, digits?: number): void;
    log_info(message: string): void;
    log_warn(message: string): void;
    log_err(message: string): void;
}
export declare const ServiceMetrics: _ServiceMetrics;
export {};
