import { ModelInstanceDocument, ModelInstanceDocumentMetadata, ModelInstanceDocumentStateMetadata } from '@ceramicnetwork/stream-model-instance';
import { CommitData, StreamConstructor, StreamHandler, StreamReader, StreamReaderWriter, StreamState } from '@ceramicnetwork/common';
import { Model } from '@ceramicnetwork/stream-model';
declare type Payload = {
    data: JsonPatchOperation[];
};
declare type JsonPatchOperation = {
    op: string;
    path: string;
    value?: any;
    from?: string;
};
interface ModelInstanceDocumentHeader extends ModelInstanceDocumentMetadata {
    unique?: Uint8Array;
}
export declare class ModelInstanceDocumentHandler implements StreamHandler<ModelInstanceDocument> {
    private readonly _schemaValidator;
    constructor();
    get type(): number;
    get name(): string;
    get stream_constructor(): StreamConstructor<ModelInstanceDocument>;
    applyCommit(commitData: CommitData, context: StreamReaderWriter, state?: StreamState<ModelInstanceDocumentStateMetadata>): Promise<StreamState>;
    _applyGenesis(commitData: CommitData, context: StreamReaderWriter): Promise<StreamState>;
    _applySigned(commitData: CommitData, state: StreamState<ModelInstanceDocumentStateMetadata>, context: StreamReaderWriter): Promise<StreamState>;
    _applyAnchor(commitData: CommitData, state: StreamState): Promise<StreamState>;
    _validateModel(model: Model): void;
    _validateContent(ceramic: StreamReader, model: Model, content: any, genesis: boolean, payload?: Payload, skipImmutableFieldsCheck?: boolean): Promise<void>;
    _validateRelationsContent(ceramic: StreamReader, model: Model, content: any): Promise<void>;
    _validateHeader(model: Model, header: ModelInstanceDocumentHeader): Promise<void>;
    _validateLockedFieldsUpdate(model: Model, payload: Payload): Promise<void>;
    _validateUnique(model: Model, metadata: ModelInstanceDocumentMetadata, content: Record<string, unknown> | null): Promise<void>;
}
export {};
//# sourceMappingURL=model-instance-document-handler.d.ts.map